generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     Int                 @id @default(autoincrement())
  username               String              @unique @db.VarChar(50)
  passwordHash           String              @map("password_hash") @db.VarChar(255)
  fullName               String              @map("full_name") @db.VarChar(100)
  email                  String?             @unique @db.VarChar(100)
  role                   UserRole            @default(user)
  isActive               Boolean             @default(true) @map("is_active")
  createdAt              DateTime            @default(now()) @map("created_at")
  updatedAt              DateTime            @updatedAt @map("updated_at")
  lastLogin              DateTime?           @map("last_login")
  autoAssignEnabled      Boolean             @default(true) @map("auto_assign_enabled")
  lastAssignedAt         DateTime?           @map("last_assigned_at")
  approvedRequests       AutoAssignRequest[] @relation("AutoAssignApprover")
  autoAssignRequests     AutoAssignRequest[]
  notifications          Notification[]
  passwordResets         PasswordReset[]
  comments               TicketComment[]
  assignedTickets        Ticket[]            @relation("AssignedTo")
  userActivitiesAsAdmin  UserActivity[]      @relation("UserActivityAdmin")
  userActivitiesAsTarget UserActivity[]      @relation("UserActivityTarget")

  @@map("users")
}

model PasswordReset {
  id        Int      @id @default(autoincrement())
  userId    Int      @map("user_id")
  token     String   @unique @db.VarChar(255)
  expiresAt DateTime @map("expires_at")
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@map("password_resets")
}

model Ticket {
  id                 Int                @id @default(autoincrement())
  ticketId           String             @unique @map("ticket_id") @db.VarChar(20)
  problemType        String             @map("problem_type") @db.VarChar(50)
  otherProblemType   String?            @map("other_problem_type") @db.VarChar(100)
  problemDescription String             @map("problem_description")
  fullName           String             @map("full_name") @db.VarChar(100)
  phoneNumber        String             @map("phone_number") @db.VarChar(15)
  department         String             @db.VarChar(100)
  division           String             @db.VarChar(100)
  assetNumber        String?            @map("asset_number") @db.VarChar(50)
  status             String             @default("รอดำเนินการ") @db.VarChar(30)
  priority           String             @default("ปกติ") @db.VarChar(20)
  assignedToId       Int?               @map("assigned_to")
  createdAt          DateTime           @default(now()) @map("created_at")
  updatedAt          DateTime           @updatedAt @map("updated_at")
  resolvedAt         DateTime?          @map("resolved_at")
  clientIp           String?            @map("client_ip") @db.VarChar(45)
  notifications      Notification[]
  attachments        TicketAttachment[]
  comments           TicketComment[]
  assignedTo         User?              @relation("AssignedTo", fields: [assignedToId], references: [id])

  @@index([status])
  @@index([assignedToId])
  @@index([createdAt])
  @@index([problemType])
  @@index([department])
  @@index([fullName])
  @@index([status, createdAt])
  @@index([assignedToId, status])
  @@map("tickets")
}

model TicketComment {
  id          Int         @id @default(autoincrement())
  ticketId    Int         @map("ticket_id")
  userId      Int?        @map("user_id")
  comment     String
  commentType CommentType @default(comment) @map("comment_type")
  isInternal  Boolean     @default(false) @map("is_internal")
  createdAt   DateTime    @default(now()) @map("created_at")
  ticket      Ticket      @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user        User?       @relation(fields: [userId], references: [id])

  @@index([ticketId])
  @@index([isInternal])
  @@index([ticketId, createdAt])
  @@map("ticket_comments")
}

model Notification {
  id        Int      @id @default(autoincrement())
  userId    Int      @map("user_id")
  ticketId  Int      @map("ticket_id")
  title     String   @db.VarChar(200)
  message   String
  isRead    Boolean  @default(false) @map("is_read")
  createdAt DateTime @default(now()) @map("created_at")
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([userId, isRead])
  @@index([createdAt])
  @@map("notifications")
}

model TicketAttachment {
  id               Int      @id @default(autoincrement())
  ticketId         Int      @map("ticket_id")
  filename         String   @db.VarChar(255)
  originalFilename String   @map("original_filename") @db.VarChar(255)
  mimetype         String   @db.VarChar(100)
  size             Int
  filePath         String   @map("file_path")
  uploadedAt       DateTime @default(now()) @map("uploaded_at")
  ticket           Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId])
  @@index([filename])
  @@map("ticket_attachments")
}

model Category {
  id          Int      @id @default(autoincrement())
  name        String   @unique @db.VarChar(50)
  description String?  @db.VarChar(255)
  isActive    Boolean  @default(true) @map("is_active")
  sortOrder   Int      @default(0) @map("sort_order")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@index([isActive, sortOrder])
  @@map("categories")
}

model Priority {
  id          Int      @id @default(autoincrement())
  name        String   @unique @db.VarChar(30)
  level       Int      @unique
  description String?  @db.VarChar(255)
  slaHours    Int      @map("sla_hours")
  color       String?  @db.VarChar(20)
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@index([isActive, level])
  @@map("priorities")
}

model AutoAssignRequest {
  id          Int       @id @default(autoincrement())
  userId      Int       @map("user_id")
  requestType String    @map("request_type") @db.VarChar(20)
  reason      String?   @db.VarChar(500)
  status      String    @default("pending") @db.VarChar(20)
  adminNotes  String?   @map("admin_notes") @db.VarChar(500)
  approvedBy  Int?      @map("approved_by")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  approvedAt  DateTime? @map("approved_at")
  approver    User?     @relation("AutoAssignApprover", fields: [approvedBy], references: [id])
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("auto_assign_requests")
}

model UserActivity {
  id          Int      @id @default(autoincrement())
  userId      Int?     @map("user_id")
  adminId     Int      @map("admin_id")
  action      String   @db.VarChar(50)
  targetType  String   @map("target_type") @db.VarChar(20)
  targetId    String?  @map("target_id") @db.VarChar(50)
  description String   @db.VarChar(500)
  metadata    String?
  createdAt   DateTime @default(now()) @map("created_at")
  admin       User     @relation("UserActivityAdmin", fields: [adminId], references: [id])
  user        User?    @relation("UserActivityTarget", fields: [userId], references: [id])

  @@index([userId])
  @@index([adminId])
  @@index([action])
  @@index([createdAt])
  @@map("user_activities")
}

enum UserRole {
  admin
  support
  user
}

enum TicketStatus {
  PENDING
  IN_PROGRESS
  WAITING_INFO
  COMPLETED
  CANCELLED
}

enum TicketPriority {
  CRITICAL
  URGENT
  HIGH
  ELEVATED
  NORMAL
  LOW
  VERY_LOW
  LOWEST
}

enum CommentType {
  comment
  status_change
  assignment
}
